/*JSDOC comment templates were auto-generated by Co-pilot. Tailored by me to make them more appropriate*/
const db = require("./database.js");
//Import the database
const joi = require("joi");
//Import joi

//Schemas for joi validation

/**
 * Joi Schema for validating IDs
 *
 * @type {Object}
 * @property {number} id - The ID which must be an integer and is required.
 */
//ID schema
const idSchema = joi.object({
    id: joi.number().integer().required()
});

/**
 * Joi Schema for validating an inputted word
 *
 * @type {Object}
 * @property {number} lang_id - The ID which must be an integer and is required.
 * @property {string} word - The string must be a series of letters (a word) or a sentence
 */
//Word schema
const wordSchema = joi.object({
    lang_id: joi.number().integer().required(),
    //Words need to be capitalized
    word: joi.string().pattern(/^[a-zA-ZÄÖäö' -]*$/).required(),
});

/**
 * Joi Schema for validating an inputted word
 *
 * @type {Object}
 * @property {number} word_id - The id of the word must be an integer
 * @property {number} trans_id - The id of the word it translates to must be an integer
 */
//Trans schema
const transSchema = joi.object({
    word_id: joi.number().integer().required(),
    trans_id: joi.number().integer().required(),
});
/**
 * Joi Schema for validating an edit of a word
 *
 * @type {Object}
 * @property {number} id - The id of the word must be an integer
 * @property {number} lang_id - The id of the language in the word. Must be an integer
 * @property {string} word - The string must be a series of letters (a word) or a sentence
 */
//Edit schema
const editSchema = joi.object({
    id: joi.number().integer().required(),
    lang_id: joi.number().integer().required(),
    word: joi.string().pattern(/^[a-zA-Z]+[a-zA-Z-' ]*$/).required(),
});
/**
 * Retrieves all languages from the database.
 *
 * @returns {Promise<Object[]>} - A promise that resolves to an array of language objects.
 * @throws {Object} - An error object with a status code and message if the query fails or no languages are found.
 */
const getAllLanguages = () => {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM languages', (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If no languages found (Would be pretty weird huh?)
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'No languages found'
                });
                return;
            };
            resolve(rows);
        });
    });
};

/**
 * Retrieves a language from the database by its ID.
 *
 * @param {number} id - The ID of the language to retrieve.
 * @returns {Promise<Object>} - A promise that resolves to the language object if found, or rejects with an error object.
 * @throws {Object} - An error object with a status code and message if validation fails, the language is not found, or a database error occurs.
 */
const getLanguageById = (id) => {
    return new Promise((resolve, reject) => {
        //Validate the id
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        }
        db.get('SELECT * FROM languages WHERE id = ?', [id], (err, row) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            if (!row) {
                reject({
                    status: 404,
                    message: 'Inserted language does not exist'
                });
                return;
            };
            resolve(row);
        });
    });
};

/**
 * Retrieves all words from the database.
 *
 * @returns {Promise<Object[]>} - A promise that resolves to an array of word objects.
 * @throws {Object} - An error object with a status code and message if the query fails or no words are found.
 */
const getAllWords = () => {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM words', (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If no words found
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'No words found'
                });
                return;
            };
            //Resolve returns all taken data
            resolve(rows);
        });
    });
};

/**
 * Retrieves all translations from the database.
 *
 * @returns {Promise<Object[]>} - A promise that resolves to an array of translation objects.
 * @throws {Object} - An error object with a status code and message if the query fails or no translations are found.
 */
const getAllTranslations = () => {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM translations', (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If no translations found
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'No translations found'
                });
                return;
            };
            //Resolve returns all taken data
            resolve(rows);
        });
    });
};

/**
 * Retrieves a word from the database by its ID.
 *
 * @param {number} id - The ID of the word to retrieve.
 * @returns {Promise<Object>} - A promise that resolves to the word object if found, or rejects with an error object.
 * @throws {Object} - An error object with a status code and message if the ID is invalid, the word is not found, or a server error occurs.
 */
const getWordsById = (id) => {
    return new Promise((resolve, reject) => {
        //Validation
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        };
        db.get('SELECT * FROM words WHERE id = ?', [id], (err, row) => {
            //If something goes wrong in the server
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If not found
            if (!row) {
                reject({
                    status: 404,
                    message: 'Word not found'
                });
                return;
            };
            //Resolve and give the specific row from database
            resolve(row);
        });
    });
};

/**
 *  Redundant function to get a translation by its own id (rather than
 * searching by word's id)
 *
 * @param {number} id - The id of the translation to retrieve
 * @returns {Promise<Object>} - A promise that will reject or resolve depending if the translation is found
 * @throws {Object} - An error if you input the id incorrectly, server fricks up or the translation is not found
 */
//Redundant. Use only if really needed
const getTranslationsById = (id) => {
    return new Promise((resolve, reject) => {
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        };
        db.get('SELECT * FROM translations WHERE id = ?', [id], (err, row) => {
            //If something goes wrong in the server
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If not found
            if (!row) {
                reject({
                    status: 404,
                    message: 'Tanslations not found'
                });
                return;
            };
            //Resolve and give the specific row from database
            resolve(row);
        });
    });
};


/**
 * Retrieves translations by word ID from the database.
 *
 * @param {number} id - The ID of the word to retrieve translations for.
 * @returns {Promise<Object[]>} - A promise that resolves to an array of translation objects.
 * @throws {Object} - An error object with a status code and message if validation fails or if there is a database error.
 */
const getTranslationsByWordId = (id) => {
    return new Promise((resolve, reject) => {
        //Validate
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        };
        //Seek all translations where word id matches up
        db.all('SELECT * FROM translations WHERE word_id = ?', [id], (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'Translations not found'
                });
                return;
            };
            resolve(rows);
        });
    });
};

/**
 * Inserts a new word into the database for a given language.
 *
 * @param {number} langId - The ID of the language.
 * @param {string} word - The word to be inserted.
 * @returns {Promise<Object>} - A promise that resolves with the inserted word's details or rejects with an error object.
 * @throws {Object} - If the input data is invalid or if there is a database error.
 */
const postWords = async (langId, word) => {
    return new Promise((resolve, reject) => {
        //Validate the word and make the first letter uppercase
        word = word.charAt(0).toUpperCase() + word.slice(1);
        const { error } = wordSchema.validate({ lang_id: langId, word: word });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. LangID should be an integer and text coherent without any special characters"
            });
            return;
        };
        db.serialize(() => {
            db.get('SELECT * FROM languages WHERE id = ?', [langId], (err, row) => {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                if (!row) {
                    reject({
                        status: 404,
                        message: 'Inserted language does not exist'
                    });
                    return;
                };
            });
            db.run('INSERT INTO words (lang_id, word) VALUES (?, ?)', [langId, word], function (err) {
                if (err) {
                    //Unique constraint error
                    if (err.code === 'SQLITE_CONSTRAINT') {
                        reject({
                            status: 409,
                            message: 'Word already exists'
                        });
                        return;
                    };
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                }
                //Resolve and show the data
                resolve({
                    id: this.lastID,
                    lang_id: langId,
                    word: word
                });
            });
        });
    });
};

/**
 * Adds a translation between two words in the database.
 *
 * @param {number} id - The ID of the word to be translated.
 * @param {number} transId - The ID of the translation word.
 * @returns {Promise<Object>} - A promise that resolves with the translation details or rejects with an error object.
 * @throws {Object} - An error object with a corresponding status and message depending on the nature of the error
 */

const postTranslations = (id, transId) => {
    return new Promise((resolve, reject) => {
        const { error } = transSchema.validate({ word_id: id, trans_id: transId });
        //Validate
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. Make sure IDs are correctly sent as integers"
            })
            return;
        };
        //Check if the word id exists
        db.serialize(() => {
            db.get('SELECT * FROM words WHERE id = ?', [id], (err, wordRow) => {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                if (!wordRow) {
                    reject({
                        status: 404,
                        message: 'Word not found'
                    });
                    return;
                };
                //See if word transID exists
                db.get('SELECT * FROM words WHERE id = ?', [transId], (err, transRow) => {
                    if (err) {
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    };
                    if (!transRow) {
                        reject({
                            status: 404,
                            message: 'Translation word not found'
                        });
                        return;
                    };
                    //Block if both words are in the same language
                    if (wordRow.lang_id === transRow.lang_id) {
                        reject({
                            status: 400,
                            message: 'Words in the same language cannot be linked as translations'
                        });
                        return;
                    };
                    //Add the translation
                    db.run('INSERT INTO translations (word_id, trans_id) VALUES (?, ?)', [id, transId], function (err) {
                        if (err) {
                            if (err.message.includes('UNIQUE')) {
                                reject({
                                    status: 409,
                                    message: 'Translation already exists'
                                });
                                return;
                            }
                            reject({
                                status: 500,
                                message: err.message
                            });
                            return;
                        };
                        /*Add the translation other way around. This was harder to figure out with
                        comma separation hence the change.*/
                        db.run('INSERT INTO translations (word_id, trans_id) VALUES (?, ?)', [transId, id], function (err) {
                            if (err) {
                                if (err.message.includes('UNIQUE')) {
                                    reject({
                                        status: 409,
                                        message: 'Reverse translation already exists'
                                    });
                                    return;
                                };
                                reject({
                                    status: 500,
                                    message: err.message
                                });
                                return;
                            };
                            resolve({
                                id: this.lastID,
                                wordId: id,
                                transId: transId
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Deletes a word and its related translations from the database.
 *
 * @param {number} id - The ID of the word to delete.
 * @returns {Promise<void>} - A promise that resolves when the word and its translations are deleted.
 * @throws {Object} - An error object with a status and message if validation fails or a database error occurs.
 */

const deleteWord = async (id) => {
    return new Promise((resolve, reject) => {
        const { error } = idSchema.validate({ id: id });
        //Validate
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        };
        db.serialize(() => {
            //Ensure the word exists
            db.get('SELECT * FROM words WHERE id = ?', [id], (err, row) => {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                if (!row) {
                    reject({
                        status: 404,
                        message: 'Word not found'
                    });
                    return;
                };
            });
            db.run('DELETE FROM words WHERE id = ?', [id], function (err) {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                //Delete any translation related to the word
                db.run('DELETE FROM translations WHERE word_id = ? OR trans_id = ?', [id, id], function (err) {
                    if (err) {
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    };
                    resolve();
                });
            });
        });
    });
};

/**
 * Deletes a translation from the database.
 *
 * @param {number} id - The ID of the word.
 * @param {number} transId - The ID of the translation.
 * @returns {Promise<void>} - A promise that resolves when the translation is deleted.
 * @throws {Object} - An error object with a status code and message if validation fails, the translation is not found, or a database error occurs.
 */

const deleteTranslation = (id, transId) => {
    return new Promise((resolve, reject) => {
        const { error } = transSchema.validate({ word_id: id, trans_id: transId });
        //Validate the ids
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. Make sure IDs are correctly sent as integers"
            })
            return;
        };
        db.serialize(() => {
            //Check if the translation exists first before executing
            db.get('SELECT * FROM translations WHERE word_id = ? AND trans_id = ?', [id, transId], (err, row) => {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                if (!row) {
                    reject({
                        status: 404,
                        message: 'Translation not found'
                    });
                    return;
                };
                //Delete the initial translation
                db.run('DELETE FROM translations WHERE word_id = ? AND trans_id = ?', [id, transId], function (err) {
                    if (err) {
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    };
                    //And the ol' switcheroo
                    db.run('DELETE FROM translations WHERE word_id = ? AND trans_id = ?', [transId, id], function (err) {
                        if (err) {
                            reject({
                                status: 500,
                                message: err.message
                            });
                            return;
                        };
                        resolve();
                    });
                });
            });
        });
    });
};

/**
 * Edits a word in the database.
 *
 * @param {number} id - The ID of the word to be edited.
 * @param {number} newLang - The new language ID for the word.
 * @param {string} newWord - The new word text.
 * @returns {Promise<Object>} - A promise that resolves when the word is successfully edited.
 * @throws {Object} - An error object with a status code and message if the operation fails.
 */

const editWord = async (id, newLang, newWord) => {
    return new Promise((resolve, reject) => {
        const { error } = editSchema.validate({ id: id, lang_id: newLang, word: newWord });
        //Validate the edit
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. IDs should be integers and text coherent without any special characters"
            });
            return;
        }

        db.serialize(() => {
            //Make sure word exists
            db.get('SELECT * FROM words WHERE id = ?', [id], (err, wordRow) => {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                }
                if (!wordRow) {
                    reject({
                        status: 404,
                        message: 'Word not found'
                    });
                    return;
                }
                //Make sure language exists
                db.get('SELECT * FROM languages WHERE id = ?', [newLang], (err, langRow) => {
                    if (err) {
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    }
                    if (!langRow) {
                        reject({
                            status: 404,
                            message: 'Inserted language does not exist'
                        });
                        return;
                    }
                    //Update the words table
                    db.run('UPDATE words SET lang_id = ?, word = ? WHERE id = ?',
                        [newLang, newWord, id],
                        function (err) {
                            if (err) {
                                if (err.code === 'SQLITE_CONSTRAINT') {
                                    reject({
                                        status: 409,
                                        message: 'Edited word already exists'
                                    });
                                } else {
                                    reject({
                                        status: 500,
                                        message: err.message
                                    });
                                }
                                return;
                            }
                            //Resolve
                            resolve({
                                id: id,
                                lang_id: newLang,
                                word: newWord
                            });
                        }
                    );
                });
            });
        });
    });
};




//Export all the modules for the router.js
module.exports = {
    getAllLanguages,
    getAllWords,
    getAllTranslations,
    getWordsById,
    getLanguageById,
    getTranslationsById,
    getTranslationsByWordId,
    postWords,
    postTranslations,
    deleteWord,
    deleteTranslation,
    editWord,
};
