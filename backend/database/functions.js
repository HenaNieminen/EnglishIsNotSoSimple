/*Most of the JSDoc comments were autogenerated by co-pilot. I tweaked some of them but they still may have some
irregularities or dumb mistakes to be ironed out. Will be updated as these may not be final */
const db = require("./database.js");
//Import the database
const joi = require("joi");
//Import joi

//Schemas for joi validation

/**
 * Joi Schema for validating IDs
 *
 * @type {Object}
 * @property {number} id - The ID which must be an integer and is required.
 */
//ID schema
const idSchema = joi.object({
    id: joi.number().integer().required()
});

/**
 * Joi Schema for validating an inputted word
 *
 * @type {Object}
 * @property {number} lang_id - The ID which must be an integer and is required.
 * @property {string} word - The string must be a series of letters (a word) or a sentence
 */
//Word schema
const wordSchema = joi.object({
    lang_id: joi.number().integer().required(),
    word: joi.string().pattern(/^[a-zA-Z]+[a-zA-Z-' ]*$/).required(),
});

/**
 * Joi Schema for validating an inputted word
 *
 * @type {Object}
 * @property {number} word_id - The id of the word must be an integer
 * @property {number} trans_id - The id of the word it translates to must be an integer
 */
//Trans schema
const transSchema = joi.object({
    word_id: joi.number().integer().required(),
    trans_id: joi.number().integer().required(),
});
/**
 * Joi Schema for validating an edit of a word
 *
 * @type {Object}
 * @property {number} id - The id of the word must be an integer
 * @property {number} lang_id - The id of the language in the word. Must be an integer
 * @property {string} word - The string must be a series of letters (a word) or a sentence
 */
//Edit schema
const editSchema = joi.object({
    id: joi.number().integer().required(),
    lang_id: joi.number().integer().required(),
    word: joi.string().pattern(/^[a-zA-Z]+[a-zA-Z-' ]*$/).required(),
});
/**
 * Retrieves all languages from the database.
 *
 * @returns {Promise<Object[]>} - A promise that resolves to an array of language objects.
 * @throws {Object} - An error object with a status code and message if the query fails or no languages are found.
 */
const getAllLanguages = () => {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM languages', (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If no languages found (Would be pretty weird huh?)
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'No languages found'
                });
                return;
            };
            resolve(rows);
        });
    });
};

/**
 * Retrieves a language from the database by its ID.
 *
 * @param {number} id - The ID of the language to retrieve.
 * @returns {Promise<Object>} - A promise that resolves to the language object if found, or rejects with an error object.
 * @throws {Object} - An error object with a status code and message if validation fails, the language is not found, or a database error occurs.
 */
const getLanguageById = (id) => {
    return new Promise((resolve, reject) => {
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        }
        db.get('SELECT * FROM languages WHERE id = ?', [id], (err, row) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            if (!row) {
                reject({
                    status: 404,
                    message: 'Inserted language not found'
                });
                return;
            };
            resolve(row);
        });
    });
};

/**
 * Retrieves all words from the database.
 *
 * @returns {Promise<Object[]>} - A promise that resolves to an array of word objects.
 * @throws {Object} - An error object with a status code and message if the query fails or no words are found.
 */
const getAllWords = () => {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM words', (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If no words found
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'No words found'
                });
                return;
            };
            //Resolve returns all taken data
            resolve(rows);
        });
    });
};

/**
 * Retrieves all translations from the database.
 *
 * @returns {Promise<Object[]>} - A promise that resolves to an array of translation objects.
 * @throws {Object} - An error object with a status code and message if the query fails or no translations are found.
 */
const getAllTranslations = () => {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM translations', (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If no translations found
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'No translations found'
                });
                return;
            };
            //Resolve returns all taken data
            resolve(rows);
        });
    });
};

/**
 * Retrieves a word from the database by its ID.
 *
 * @param {number} id - The ID of the word to retrieve.
 * @returns {Promise<Object>} - A promise that resolves to the word object if found, or rejects with an error object.
 * @throws {Object} - An error object with a status code and message if the ID is invalid, the word is not found, or a server error occurs.
 */
const getWordsById = (id) => {
    return new Promise((resolve, reject) => {
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        }
        db.get('SELECT * FROM words WHERE id = ?', [id], (err, row) => {
            //If something goes wrong in the server
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If not found
            if (!row) {
                reject({
                    status: 404,
                    message: 'Word not found'
                });
                return;
            };
            //Resolve and give the specific row from database
            resolve(row);
        });
    });
};

//Probably an useless function. Will most likely be deleted later
const getTranslationsById = (id) => {
    return new Promise((resolve, reject) => {
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        }
        db.get('SELECT * FROM translations WHERE id = ?', [id], (err, row) => {
            //If something goes wrong in the server
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            //If not found
            if (!row) {
                reject({
                    status: 404,
                    message: 'Tanslations not found'
                });
                return;
            };
            //Resolve and give the specific row from database
            resolve(row);
        });
    });
};


/**
 * Retrieves translations by word ID from the database.
 *
 * @param {number} id - The ID of the word to retrieve translations for.
 * @returns {Promise<Object[]>} - A promise that resolves to an array of translation objects.
 * @throws {Object} - An error object with a status code and message if validation fails or if there is a database error.
 */
const getTranslationsByWordId = (id) => {
    return new Promise((resolve, reject) => {
        const { error } = idSchema.validate({ id: id });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. ID should be an integer"
            });
            return;
        }
        db.all('SELECT * FROM translations WHERE word_id = ?', [id], (err, rows) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            if (rows.length === 0) {
                reject({
                    status: 404,
                    message: 'Translations not found'
                });
                return;
            };
            resolve(rows);
        });
    });
};

/**
 * Inserts a new word into the database for a given language.
 *
 * @param {number} langId - The ID of the language.
 * @param {string} word - The word to be inserted.
 * @returns {Promise<Object>} - A promise that resolves with the inserted word's details or rejects with an error object.
 * @throws {Object} - If the input data is invalid or if there is a database error.
 */
const postWords = async (langId, word) => {
    return new Promise(async (resolve, reject) => {
        //Will refuse if the word is empty. Will also be handled in frontend for redundancy
        try {
            const { error } = wordSchema.validate({ lang_id: langId, word: word });
            if (error) {
                reject({
                    status: 400,
                    message: "Incorrect data inputted. LangID should be an integer and text coherent without any special characters"
                });
                return;
            }
            await getLanguageById(langId);
            db.run('INSERT INTO words (lang_id, word) VALUES (?, ?)', [langId, word], function (err) {
                if (err) {
                    //Unique constraint error
                    if (err.code === 'SQLITE_CONSTRAINT') {
                        reject({
                            status: 409,
                            message: 'Word already exists'
                        });
                        return;
                    };
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                }
                //Resolve and show the data
                resolve({
                    id: this.lastID,
                    lang_id: langId,
                    word: word
                });
            });
        } catch (error) {
            reject(error);
        }
    });
};

/**
 * Adds a translation between two words in the database.
 *
 * @param {number} id - The ID of the word to be translated.
 * @param {number} transId - The ID of the translation word.
 * @returns {Promise<Object>} - A promise that resolves with the translation details or rejects with an error object.
 * @throws {Object} - An error object with a corresponding status and message depending on the nature of the error
 */

const postTranslations = (id, transId) => {
    return new Promise((resolve, reject) => {
        //Reject if any value is empty
        const { error } = transSchema.validate({ word_id: id, trans_id: transId });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. Make sure IDs are correctly sent as integers"
            })
            return;
        };
        //Check if the word id exists
        db.get('SELECT * FROM words WHERE id = ?', [id], (err, wordRow) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            if (!wordRow) {
                reject({
                    status: 404,
                    message: 'Word not found'
                });
                return;
            };
            //See if word transID exists
            db.get('SELECT * FROM words WHERE id = ?', [transId], (err, transRow) => {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                if (!transRow) {
                    reject({
                        status: 404,
                        message: 'Translation word not found'
                    });
                    return;
                };
                //Block if both words are in the same language
                if (wordRow.lang_id === transRow.lang_id) {
                    reject({
                        status: 400,
                        message: 'Words in the same language cannot be linked as translations'
                    });
                    return;
                };
                //Add the translation
                db.run('INSERT INTO translations (word_id, trans_id) VALUES (?, ?)', [id, transId], function (err) {
                    if (err) {
                        if (err.message.includes('UNIQUE')) {
                            reject({
                                status: 409,
                                message: 'Translation already exists'
                            });
                            return;
                        }
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    };
                    /*Add the translation other way around. This was harder to figure out with
                    comma separation hence the change.*/
                    db.run('INSERT INTO translations (word_id, trans_id) VALUES (?, ?)', [transId, id], function (err) {
                        if (err) {
                            if (err.message.includes('UNIQUE')) {
                                reject({
                                    status: 409,
                                    message: 'Reverse translation already exists'
                                });
                                return;
                            };
                            reject({
                                status: 500,
                                message: err.message
                            });
                            return;
                        };
                        resolve({
                            id: this.lastID,
                            wordId: id,
                            transId: transId
                        });
                    });
                });
            });
        });
    });
};

/**
 * Deletes a word and its related translations from the database.
 *
 * @param {number} id - The ID of the word to delete.
 * @returns {Promise<void>} - A promise that resolves when the word and its translations are deleted.
 * @throws {Object} - An error object with a status and message if validation fails or a database error occurs.
 */

const deleteWord = async (id) => {
    //Reuse the async promise to get it to work
    return new Promise(async (resolve, reject) => {
        try {
            const { error } = idSchema.validate({ id: id });
            if (error) {
                reject({
                    status: 400,
                    message: "Incorrect data inputted. ID should be an integer"
                });
                return;
            }
            //Ensure the word exists
            await getWordsById(id);
            db.run('DELETE FROM words WHERE id = ?', [id], function (err) {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                //Delete any translation related to the word
                db.run('DELETE FROM translations WHERE word_id = ? OR trans_id = ?', [id, id], function (err) {
                    if (err) {
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    };
                    resolve();
                });
            });
            //Catch getwordsbyid error
        } catch (error) {
            reject(error);
        };
    });
};

/**
 * Deletes a translation from the database.
 *
 * @param {number} id - The ID of the word.
 * @param {number} transId - The ID of the translation.
 * @returns {Promise<void>} - A promise that resolves when the translation is deleted.
 * @throws {Object} - An error object with a status code and message if validation fails, the translation is not found, or a database error occurs.
 */

const deleteTranslation = (id, transId) => {
    return new Promise((resolve, reject) => {
        const { error } = transSchema.validate({ word_id: id, trans_id: transId });
        if (error) {
            reject({
                status: 400,
                message: "Incorrect data inputted. Make sure IDs are correctly sent as integers"
            })
            return;
        };
        //Check if the translation exists first before executing
        db.get('SELECT * FROM translations WHERE word_id = ? AND trans_id = ?', [id, transId], (err, row) => {
            if (err) {
                reject({
                    status: 500,
                    message: err.message
                });
                return;
            };
            if (!row) {
                reject({
                    status: 404,
                    message: 'Translation not found'
                });
                return;
            };
            //Delete the initial translation
            db.run('DELETE FROM translations WHERE word_id = ? AND trans_id = ?', [id, transId], function (err) {
                if (err) {
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                //And the ol' switcheroo
                db.run('DELETE FROM translations WHERE word_id = ? AND trans_id = ?', [transId, id], function (err) {
                    if (err) {
                        reject({
                            status: 500,
                            message: err.message
                        });
                        return;
                    };
                    resolve();
                });
            });
        });
    });
};

/**
 * Edits a word in the database.
 *
 * @param {number} id - The ID of the word to be edited.
 * @param {number} newLang - The new language ID for the word.
 * @param {string} newWord - The new word text.
 * @returns {Promise<void>} - A promise that resolves when the word is successfully edited.
 * @throws {Object} - An error object with a status code and message if the operation fails.
 */

const editWord = async (id, newLang, newWord) => {
    /*This was suggested by chatGPT. Turns out, you can make promises asynchronous as well!
    This wouldn't work without setting the whole function and the promise as asynchronous. I was stumped when
    the await wouldn't work inside the promise at first. GPT suggested to make the promise asynchronous*/
    return new Promise(async (resolve, reject) => {
        try {
            const { error } = editSchema.validate({ id: id, lang_id: newLang, word: newWord });
            if (error) {
                reject({
                    status: 400,
                    message: "Incorrect data inputted. IDs should be integers and text coherent without any special characters"
                });
                return;
            }
            /*Use the get wordsid function before to ensure it exists.*/
            await getWordsById(id);
            //update the word
            db.run('UPDATE words SET lang_id = ?, word = ? WHERE id = ?', [newLang, newWord, id], function (err) {
                if (err) {
                    if (err.code === 'SQLITE_CONSTRAINT') {
                        reject({
                            status: 409,
                            message: 'Edited word already exists'
                        });
                        return;
                    };
                    reject({
                        status: 500,
                        message: err.message
                    });
                    return;
                };
                resolve();
            });
            //Catch error with getWordsById
        } catch (error) {
            reject({
                status: 404,
                message: 'Edited word not found. Double check the ID'
            });
        };
    });
};



//Export all the modules for the router.js
module.exports = {
    getAllLanguages,
    getAllWords,
    getAllTranslations,
    getWordsById,
    getLanguageById,
    getTranslationsById,
    getTranslationsByWordId,
    postWords,
    postTranslations,
    deleteWord,
    deleteTranslation,
    editWord,
};
