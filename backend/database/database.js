/*Co-pilot has autogenerated a templates for the JSDoc comments. They have been doctored
to be more appropriate, but may lack proper forms for documenting*/

const sqlite3 = require("sqlite3").verbose();
const fs = require("fs");

//Create a table to store languages
/*For the time being. I will only make a function to see them all. I will not yet
start implementing support for multiple languages. These are just for error checking so
a word from the same language can't translate to an other word from the same language */
/**
 * Creates the 'languages' table in the database.
 *
 * It will only have an ID and the language in text form
 *
 * @param {Object} db - The database connection object.
 */
const createLanguageTable = (db) => {
    db.run("CREATE TABLE languages (id INTEGER PRIMARY KEY AUTOINCREMENT, language TEXT UNIQUE);");
};

//Create words table
/**
 * Creates the 'words' table in the database.
 *
 * The 'words' table has the following columns:
 * - id: An integer primary key that auto-increments each insert.
 * - lang_id: Links the word with its respective language in the language table
 * - word: text to store the word
 * - tags: text to store the tags
 *
 * The table has a unique constraint on the combination of 'lang_id' and 'word',
 * ensuring that each word is unique within its language but allowing the same word
 * to exist in different languages (loan words and such).
 *
 * @param {object} db - The database connection object.
 */
const createWordsTable = (db) => {
    db.run(`CREATE TABLE words (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        lang_id INTEGER,
        word TEXT,
        FOREIGN KEY (lang_id) REFERENCES languages (id),
        UNIQUE(lang_id, word)
    );`);
    /*Unique constaint was modified so that words have to be unique for each language,
    but will not exclude and reject loan words in other languages*/
};

//Create translations table
/**
 * Creates the translations table in the database.
 * The table includes the following columns:
 * - id: Primary key, almost unused but for redundancy
 * - word_id: Foreign key referencing an id in the words table.
 * - trans_id: Foreign key referencing an id in the words table.
 * The combination of word_id and trans_id must be unique. So duplicates wont happen
 *
 * Main purpose of this table is to link words togheter to form a translation and most
 * of the queries concern the word_id or trans_id
 * @param {Object} db - The database connection object.
 */
const createTranslationsTable = (db) => {
    db.run(`CREATE TABLE translations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        word_id INTEGER NOT NULL,
        trans_id INTEGER NOT NULL,
        FOREIGN KEY (word_id) REFERENCES words (id),
        FOREIGN KEY (trans_id) REFERENCES words (id),
        UNIQUE(word_id, trans_id)
    );`);
    /*Converted to use duplication. I realized that comma separating them
    will cause headaches in the future. Luckily this is still easily correctable*/
};

/**
* This table stores tags for the words
*
*Columns:
*- id: Primary key, auto-incremented
*- tag: Text to store the tag
*- UNIQUE(tag): Ensures that each tag is unique in the table
*This table is used to store tags for words, allowing for better organization and categorization of words.
* @param {Object} db - The database connection object.
*
*/
const createTagsTable = (db) => {
    db.run(`CREATE TABLE tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tag TEXT NOT NULL,
        UNIQUE(tag)
    );`);
}

const createWordTagsTable = (db) => {
    db.run(`CREATE TABLE word_tags (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        word_id INTEGER,
        tag_id INTEGER,
        FOREIGN KEY (word_id) REFERENCES words (id),
        FOREIGN KEY (tag_id) REFERENCES tags (id),
        UNIQUE(word_id, tag_id)
    );`);
};



//Read the initialData.json file and insert all contents to the database
/**
 * Reads initial data from the JSON file and inserts it into the database.
 *
 * @param {object} db - The database connection object.
 *
 * The JSON file should contain the same structure as the database tables (minus auto-increment IDs).
 *
 */
const createPlaceHolderData = (db) => {
    fs.readFile(__dirname + "/initialData.json", "utf8", (err, data) => {
        //If an error occurs with reading the file
        if (err) {
            console.error("Error reading file:", err);
            return;
        };

        try {
            //Parse and read the data and then insert the each json object
            const { languages, words, translations } = JSON.parse(data);
            //Serialize to make sure they run in order
            db.serialize(() => {
                //Run languages
                languages.forEach((language) => {
                    db.run("INSERT INTO languages (language) VALUES (?)", [language], (err) => {
                        if (err) {
                            console.error("Error inserting language:", err);
                        };
                    });
                });
                //Run words
                words.forEach(({ lang_id, word }) => {
                    db.run("INSERT INTO words (lang_id, word) VALUES (?, ?)", [lang_id, word], (err) => {
                        if (err) {
                            console.error("Error inserting word:", err);
                        };
                    });
                });
                //Run translations
                translations.forEach(({ word_id, trans_id }) => {
                    db.run("INSERT INTO translations (word_id, trans_id) VALUES (?, ?)", [word_id, trans_id], (err) => {
                        if (err) {
                            console.error("Error inserting translation:", err);
                        };
                    });
                });
            });
            //Catch parsing issues
        } catch (parseError) {
            console.error("Error parsing file:", parseError);
        };
    });
};

//Create the database and all its values into memory
/**
 * Initializes an in-memory SQLite database and runs the creation functions
 *
 * @param {sqlite3.Database} db - The SQLite database instance.
 * @param {Error} error - The error object if the database creation fails.
 *
 * This function creates an in-memory SQLite database and runs all the tables
 * and the initial data to it.
 *
 */
const db = new sqlite3.Database(":memory:", (error) => {
    //If an error occurs
    if (error) {
        console.error("Database creation failed:", error);
        return;
    };
    //Run all database initializations in a series
    db.serialize(() => {
        createLanguageTable(db);
        createWordsTable(db);
        createTranslationsTable(db);
        createPlaceHolderData(db);
    });
});

module.exports = db;
